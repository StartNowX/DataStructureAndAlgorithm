> 极客时间，数据结构和算法之美，王争

## 入门篇

### 复杂度分析

#### 时间复杂度分析
1. 大O复杂度表示法
    * 表示代码执行时间随着数据规模增长的变化趋势，也叫渐进时间复杂度（asymptotic time complexity），简称时间复杂度，只需记录最大量级就可以了
    * 只关注循环执行次数最多的一段代码
    * 加法法则：总复杂度等于量级最大的那段代码的复杂度
    * 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
2. 常见的时间复杂度实例
    * 非多项式量级：指数阶（O(2^n)），阶数阶（O(n!)）
    * 多项式量级：常量阶（O(1)），对数阶（O(logn)），线性阶（O(n)）、线性对数阶（O(nlogn)）、平方阶（O(n^2)）、立方阶（O(n^3)）...

#### 空间复杂度分析
渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系，常见的有O(1)，O(n)，O(n^2)，对数阶的复杂度平时都很少用到。

#### 最好、最坏情况时间复杂度
1. 最好情况时间复杂度
    * 在理想的情况下，执行代码的时间复杂度
2. 最坏情况时间复杂度
    * 在最糟糕的情况下，执行代码的时间复杂度

#### 平均情况时间复杂度
1. 平均时间复杂度，全称加权平均时间复杂度或期望时间复杂度
2. 很多时候，一个复杂度就满足了，只有同一代码块在不同的情况下，时间复杂度有量级的差距时，才会使用此三种复杂度表示法区分

#### 均摊时间复杂度
摊还平均法
* 对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度


## 基础篇

### 数组
1. 数组是最基础、最简单的数据结构，它是用一块**连续的内存地址空间**存储**相同的类型**的一组数据。
2. 最大的特点是支持随机访问，支持随机访问时的时间复杂度是O(1)，删除、查找操作较为耗时，平均时间复杂度为O(n)。
3. 线性表结构：数组、链表、队列、栈等
4. C语言中，只要不是访问受限的内存，所有的内存空间都是可以自由访问的；数组越界在C语言中是一种未决行为，并没有规定数组访问越界时编译器应该如何处理。因为，访问数组的本质就是访问一段连续内存，**只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误**
5. 数组下标从0开始
    * 数组下标本意为“偏移”，其寻址方式为`a[k]_address = base_address + k * type_size`，因此，如果下标从0开始，则寻址时CPU需要多一次减法操作
    * 历史原因


### 链表
1. 不需要连续的内存空间，通过指针将零散的内存块串联起来，常用的有单链表、双向链表、循环链表、双向循环链表
2. 单链表，每个内存块被称为结点，每个结点除存储数据外，还有一个*后继指针*，记录下一个结点的地址，单链表的尾结点的后继指针指向为空地址NULL
    * 第一个结点为头结点，最后一个结点为尾结点
    * 插入、删除的时间复杂度为O(1)，查找的时间复杂度为O(n)
3. 双向链表：每个结点除了存储数据外，还有一个*后继指针*和一个*前驱指针*；
    * 实际使用更为频繁，常被用来以**空间换时间**，减少程序耗时
4. 循环链表：特殊的单链表，尾结点的后继指针指向头结点
5. 双向循环链表：双向链表的头尾相连
6. 数组vs链表
    * 两者在插入、删除和查找的时间复杂度正好相反
    * `数组简单易用，在实现上使用的是连续的内存空间，可以借助CPU的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以对 CPU 缓存不友好，没办法有效预读。`
    * `数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致“内存不足（out of memory）”。如果声明的数组过小，则可能出现不够用的情况。这时只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时。链表本身没有大小的限制，天然地支持动态扩容，我觉得这也是它与数组最大的区别`

7. 写链表代码的技巧
    * 理解指针或引用的含义
    * 警惕指针丢失和内存泄漏
    * 利用哨兵简化实现的难度
    * 重点留意边界条件的处理
        * 如果链表为空时，代码能否正常运行？
        * 如果链表只包含一个结点时，代码能否正常运行？
        * 如果代码只包含两个结点时，代码能否正常运行？
        * 代码逻辑在处理头结点和尾结点时，是否能够正常处理？
    * 举例画图辅助
    * 多写多练
        * 单链表的反转
        * 链表中环的检测
        * 两个有序链表的合并
        * 删除链表倒数第N个结点
        * 求链表的中间结点